# 8.Network <hr>

## 8.1 Network fundamentals, client-server architecture communication protocols

In modern computer networks, communication between devices is based on the client-server architecture, called TCP/IP (Transmission
Control Protocol/Internet Protocol), where clients request services or resources from servers. In simple terms - imagine you're
visiting a restaurant. In this scenario, you, as a customer, represent the client. You have certain needs, such as ordering food
and requesting service. The restaurant, on the other hand, represents the server. It has resources (food, staff, kitchen) that can
fulfill your needs. Similarly, in client-server architecture, the client is like a customer who sends requests for services or
resources to the server. The server is like the restaurant, which processes these requests and provides the requested services or
resources back to the client. In different words ordering food in restaurant means sending a 'request' to kitchen.

This communication relies on various protocols that govern how data is transmitted and received. Here are some key concepts with
examples:

+ IP Addresses: An IP(Internet Protocol) address is a unique identifier assigned to each device on a network. It consists of a
  series of numbers separated by dots. There are two main versions of the Internet Protocol in use today: IPv4 (Internet Protocol
  version 4) and IPv6 (Internet Protocol version 6). IPv4 addresses are 32-bit numeric addresses, expressed in a format like "
  192.168.1.1," while IPv6 addresses are 128-bit hexadecimal addresses, represented in a format like "2001:0db8:85a3:0000:0000:
  8a2e:0370:7334. In Java, you can represent an IP address using the InetAddress class.

```java
class Network {
  public static void main(String[] args) {
    try {
      InetAddress googleAddress = InetAddress.getByName("www.google.com");
      System.out.println("Host Name: " + googleAddress.getHostName());
      System.out.println("IP Address: " + googleAddress.getHostAddress());
    } catch (UnknownHostException e) {
      System.out.println("Unable to resolve host");
    }
  }
}
```

##### Output: <br/> ![ErrorImageNotFound](../zCourseImages/8_Network/getIpAddress.png)

+ Ports: Ports are used to identify specific processes or services running on a device. They are represented by numeric values
  ranging from 0 to 65535. Ports below 1024 are considered well-known ports and are typically reserved for specific services. For
  example, port 80 is commonly used for HTTP traffic, port 443 is used for HTTPS traffic, and so on. ports above 1024 are
  available for general use. You can choose any available port number to establish your client-server connection, as long as it is
  not being used by another application on the same machine. It's common practice to choose port numbers above 1024 to avoid
  conflicts with well-known ports. <br/>
  To give you an analogy:
  Think of IP addresses as street addresses for houses. Each house (device) has a unique street address (IP address) to identify
  its location. Ports are like room numbers inside each house. Each room (port) can be used for different activities or
  conversations (communication sessions) independently from each other. <br/>
  In Java, you can use the Socket class to establish connections to specific ports on remote servers.

```java
class Network {
  public static void main(String[] args) {
    String serverName = "example.com";
    int portNumber = 80;
    try (Socket socket = new Socket(serverName, portNumber)) {
      // Connection established
      // Perform further operations
    } catch (IOException e) {
      // Handle exception
    }
  }
}
```

+ Network Layers: Computer networks are organized into layers, each responsible for specific tasks. Imagine a cake with multiple
  layers. Each layer has a specific purpose and contributes to the overall structure and taste of the cake. Similarly, in a
  computer network, each layer is responsible for specific tasks related to data transmission and communication. The most commonly
  used model for network layers is the "OSI (Open Systems Interconnection) model." It consists of seven layers, each with its own
  unique role:
  + Physical Layer: This is the bottom layer and deals with the physical transmission of raw bits over a physical medium, such as
    cables or wireless signals. It handles tasks like converting digital data into electrical signals for transmission.
  + Data Link Layer: This layer manages the reliable transmission of data frames between devices on the same local network. It
    also handles error detection and correction to ensure data integrity.
  + Network Layer(Internet Layer): The network layer is responsible for routing data packets from the source to the destination
    across multiple networks. It uses IP addresses to identify devices and determine the best path for data delivery.
  + Transport Layer: This layer focuses on end-to-end communication and manages data flow between applications. It ensures
    reliable and orderly data transfer and provides error recovery mechanisms. This layer includes both the Transmission Control
    Protocol (TCP) and the User Datagram Protocol (UDP). TCP provides reliable, connection-oriented data transmission, ensuring
    that data packets are delivered in the correct order and without errors. UDP, on the other hand, is connectionless and used
    for applications that require faster data transmission, such as video streaming and online gaming.
  + Session Layer: The session layer establishes, maintains, and terminates communication sessions between applications on
    different devices. It manages the dialogue and synchronization between applications.
  + Presentation Layer: This layer is responsible for data formatting, compression, and encryption. It ensures that data from the
    application layer is presented in a readable and understandable format for transmission.
  + Application Layer: The top layer is the one closest to the user and interacts directly with applications. It provides services
    to end-user applications, such as HTTP (for web browsing), SMTP (for email), FTP (for file transfer), and DNS (for domain name
    resolution).

<hr>

## 8.2 TCP (Transmission Control Protocol):

### <u>TCP Overview and communication:</u>

TCP (Transmission Control Protocol) is a widely used communication protocol in computer networks. It operates at the Transport
Layer (Layer 4) of the OSI model and provides reliable, connection-oriented communication between two devices over a network. TCP
is responsible for ensuring that data is delivered accurately, in the correct order, and without errors. TCP enables the
establishment of a connection between a client and a server, ensuring that data is transmitted accurately. The process of
establishing a TCP connection is known as the <b>TCP three-way handshake:</b>

1. The client sends a SYN (Synchronize) packet to the server, requesting to establish a connection.
2. The server responds with a SYN-ACK (Synchronize-Acknowledge) packet, acknowledging the request and agreeing to establish a
   connection.
3. The client sends an ACK (Acknowledge) packet to the server, confirming the connection establishment.

Once the connection is established, data can be exchanged bidirectionally between the client and the server. TCP ensures that data
packets are delivered reliably by using acknowledgments and retransmissions if packets are lost or corrupted.

Let's investigate with real-life example:

+ <b>Client Requests to Watch a YouTube Video:</b> When you click on a YouTube video to watch, your web browser sends a request to
  YouTube's servers, asking for the video data.
+ <b>Finding DNS (Domain Name System):</b> Before initiating the TCP handshake, your web browser first needs to find the IP
  address of YouTube's server. It does this by querying a DNS server, which translates the human-readable domain name "
  youtube.com" into the corresponding IP address.
+ <b>TCP Handshake - Establishing Connection:</b> After obtaining the IP address, your browser can now establish a connection with
  YouTube's server using the TCP handshake:
  + Step 1: Your browser sends a "hello" message called a SYN packet to YouTube's server.
  + Step 2: YouTube's server responds with a "
    hello back" message called a SYN-ACK packet, acknowledging the receipt of the SYN packet.
  + Step 3: Your browser sends another message called an ACK packet to YouTube's server, confirming the receipt of the SYN-ACK
    packet.
+ <b>Data Transmission - Watching the Video:</b> With the connection established, YouTube's server starts sending the video data
  to your web browser. The video is divided into small data packets.
+ <b>Packet Acknowledgment:</b> As your browser receives each data packet, it sends an acknowledgment back to YouTube's server,
  indicating successful receipt. If any packet is lost or corrupted during transmission, the server retransmits it to ensure data
  integrity.
+ <b>Video Playback:</b> As the data packets are received and assembled in the correct order, your web browser starts playing the
  video. This process continues until the entire video is played.
+ <b>Connection Termination - Closing the Connection:</b> After you finish watching the video or close the YouTube page, your
  browser initiates the connection termination process:
  + Step 4: Your browser sends a "goodbye" message called a FIN packet to YouTube's server, indicating that it wants to close the
    connection.
  + Step 5: YouTube's server responds with a "goodbye back" message called a FIN-ACK packet, acknowledging the receipt of the FIN
    packet.
  + Step 6: Your browser sends a final acknowledgment called an ACK packet to YouTube's server, confirming the receipt of the
    FIN-ACK packet.
+ <b>Connection Closed:</b> Both your web browser and YouTube's server now close the connection, completing the TCP process.

Throughout this TCP process, the handshake ensures a reliable and orderly data exchange between your browser and YouTube's server.
It guarantees that the video data arrives intact and in the correct sequence, enabling you to enjoy a smooth and uninterrupted
video playback experience.

### <u>Socket Programming:</u>

In Java, developers can use Socket Programming to implement TCP connections between client and server applications. Java provides
the `Socket` and `ServerSocket` classes to facilitate this:

+ The `Socket` class represents the endpoint of a two-way communication link between a client and a server. It allows data to be
  sent and received over the network.
+ The `ServerSocket` class represents a server-side socket that listens for incoming client connection requests. When a client
  requests a connection, the `ServerSocket` creates a new `Socket` to handle communication with that client.

Here's a simple Java example demonstrating TCP communication between a client and a server on local machine:

<b> TCP Server </b>

```java
public class TCPServer {
  public static void main(String[] args) {
    try {
      System.out.println("TCP SERVER");
      ServerSocket serverSocket = new ServerSocket(12345); // Port number for communication
      System.out.println("Server started. Waiting for a client to connect...");

      Socket clientSocket = serverSocket.accept(); // Wait for a client to connect
      System.out.println("Client connected.");

      BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
      PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);

      // Server continuously listens for messages from the client
      while (true) {
        String message = in.readLine();
        if (message == null) {
          System.out.println("Client disconnected.");
          break;
        }
        System.out.println("Client: " + message);

        // Echo the message back to the client
        out.println("server received message - " + message);
      }

      in.close();
      out.close();
      clientSocket.close();
      serverSocket.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

<b> TCP Client </b>

```java
public class TCPClient {
  public static void main(String[] args) {
    try {
      System.out.println("TCP CLIENT");
      Socket clientSocket = new Socket("localhost", 12345); // Connect to the server on localhost:12345
      System.out.println("Connected to server.");

      BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
      PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
      BufferedReader consoleInput = new BufferedReader(new InputStreamReader(System.in));

      // Client continuously listens for console input and sends it to the server
      while (true) {
        System.out.print("You: ");
        String message = consoleInput.readLine();
        if (message.equalsIgnoreCase("exit")) {
          break;
        }
        out.println(message);

        String response = in.readLine();
        System.out.println("ServerResponse: " + response);
      }

      in.close();
      out.close();
      consoleInput.close();
      clientSocket.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
```

First you need to run Server side application. Then start Client side application. They will establish connection, allowing server
to listen everything is typed in console on client side. <br/> 
![ErrorImageNotFound](../zCourseImages/8_Network/socketConnection.png)


## 8.3 UDP (User Datagram Protocol):

UDP Overview and communication: This section introduces the UDP protocol, which is connectionless and provides fast, low-overhead
communication. It explains the differences between TCP and UDP and when to use UDP. DatagramPacket: It covers the DatagramPacket
class, which represents a packet of data in UDP communication. It includes information about the source and destination addresses.
DatagramSocket: This topic explains the DatagramSocket class, which allows sending and receiving UDP packets. It covers creating
and using DatagramSocket objects for UDP communication. MulticastSocket: It introduces the MulticastSocket class, which enables
sending and receiving multicast packets. It covers joining multicast groups and handling multicast communication.

### 8.4 URL and URLConnection:

This topic covers working with URLs (Uniform Resource Locators) in Java. It includes creating URL objects, establishing
connections using URLConnection, and reading data from URLs.

### 8.5 HTTP and HTTPS:

HTTP Overview: This part provides an overview of the HTTP (Hypertext Transfer Protocol), explaining its request-response model,
status codes, and headers. HTTP Client: It covers making HTTP requests from a Java application using HttpURLConnection or
HttpClient. It includes sending GET, POST, and other types of requests and handling responses. HTTPS: This topic introduces
HTTPS (HTTP Secure), which is the secure version of HTTP. It covers the basics of SSL/TLS encryption and how to establish secure
connections in Java.

### 8.6 Popular network frameworks:

This section provides an overview of popular Java network frameworks and libraries, such as Apache HttpClient, OkHttp, Netty, and
Spring WebClient. It briefly introduces their features and use cases.

### 8.7 Network security concepts & secure communication:

This topic covers network security concepts, including authentication, encryption, and digital certificates. It explains how to
ensure secure communication over networks and prevent unauthorized access or data breaches.

### 8.8 Network troubleshooting & debugging:

This section explores common issues and techniques for troubleshooting and debugging network-related problems. It covers tools,
techniques, and best practices for diagnosing and resolving network issues in Java applications.

<hr>
